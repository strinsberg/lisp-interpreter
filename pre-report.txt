Pre-report for 3740 project

-- How did you organize your program
Broke it into small functions for each type of expression
Put the eval functions first and followed them with things related to
builtin functions and the variable stack.
Then included sections for evaluating specific expression types,
starting with simple and moving to more complex.
Then followed this up with helper functions and any functionality
that was extra to the project description.

-- What key data structures did you use? and what ar they used for?
Used hash tables to store the local bindings for each level of scope
Stored those in a stack that I made out of a list and wrote some
functions to push and pop the hash tables off of.
Also used procedures to store lambda expressions so they could be
evaluated later on their arguments and appropriately deal with
any variables that were present at the time. This also extended to
any other built in procedure that I passed through a function so
that it would have the same structure as my lambda procedures. This
enabled me to easily add any base racket functions that I wanted
by simply passing them through a function and storing the resulting
procedure on the top level of the stack. This process is limited to
procedures that take a fixed number of arguments. and I only did it
for procedures with 1,2 or 3 arguments as this covers most of the
basic and commonly used racket procedures.

-- Limitations and bugs
Limited checking for errors -> though this is not necessary
There are currently no limitations as far as the project
description is concerned, however, I implemented limited error
checking for things like undefined variables and tried to limit
dynamic scopeing. Some programs that wouldn't run in racket would
most likely run on my interpreter with no errors.

-- Testing strategy and sample tests
wrote simple tests for each type of supported procedure.
Passed the racket program to be evaluated by racket and by my
interpreter and compared the results. This allowed me to know when
a program would not run in racket, so any error in my program would
not be a concern if the program was not valid. It also allowed
changing and reorganizing of the code while easily seeing if
there was any change in the interpreters results.
I used some more complicated programs provided by howard and some
of my own design to test complicated and unique scenarios on my
interpreter. I also tried to rewrite my assignment submissions with
the syntax that would enable me to run them on my interpreter to
test even more functions. I regret being unable to write my
interpreter in such a way that I could run it on itself, but this
would certainly be far more work than is necessary for this
project (though it would be fun to do).

-- Additional Code documentation
Lambda

evaluation of multiple expressions in the body of lambda,let,letrec

Variable checking and replacement

Built in procedures

Let/Letrec





###############################################################
Program organization
1. Took every rule for evaluating an expression and mad it it's
  own function.
2. Set up startEval() to call a recursive function with the base
  environment to start the interpreter
3. By splitting up the rules for evaluating things into functions
  I was able to make my eval function relatively simple so that it
  is not filled with code to evaluate each possible operator. This
  to me means that the code is more readable and extendable. (maybe
  not the point of this project) this way as more kinds of expressions
  are added to the interpreter it does not require adding many
  more conditions to the myEval() funciton
4. Built a base environment of all the built in racket funcitons
  that were to be added. This makes the code a lot cleaner and
  means that the base environment has a reference to all the possible
  procedures. This makes it much easier to re-bind a procedure or
  to pass procedures around. It uses rackets built in funcitonality
  to deal with simple expressions rather than re-coding how to deal
  with them.
5. Organization of sections to see each necessary part of the program
  and then put the parts that it uses after the section. first any
  constants or defines, then the eval functions, then the base
  environment set-up, then some code to deal with bindings and lookups
  in the evironment, simple expressions like if and quote, then lambda,
  and both lets.

Key Data structures
1. List
  - Used this for my environment and for bindings
  - the environment is just a list of bindings that acts a little
  like a stack. The car end is sort of the top and each set of
  bindings is added to the front of it with append.
  - when making a set of bindings a list is used to store them and
  cons is used to add each new binding to this set.
  - The bindings themselves are just tuples of (symbol value) which
  makes it easy to look up and find a variables value. the first
  element of a binding is the symbol to match and the second can be
  returned by the lookup function if it exists.
  - I also have a constant to return for bindings that are not found
  which i use for throwing errors like the racket interpreter so I
  can find whether a problem came from not finding sometjing or trying
  to evaluate it with racket.
2. Procedures/Closures
  - These are used for all my builtin bindings and my lambda.
  - First my lambda returns a procedure to be called when it is needed.
  this lets racket take care of creating a closure for me with the
  environment that is around when the lambda procedure is created.
  - Because of the way my lambda works (more below) I also ended up using
  procuedures to wrap any procedure that I could and formatted all my
  expression functions the same way as lambda and these. So every
  procedure in my interpreter is formated the same. It takes a list
  of arguments and an environments. So procedures for unary, binary,
  and ternary operations from base racket are wrapped in another procedure
  that takes these arguments and uses what it needs. For example. '+ is
  is a binary operator and I wrapped it in a function that evaluates the
  first two arguments of the list of arguments it is passed with the passed
  envirionment and then applies the '+ operator to the result. So these
  wrappers take a procedure and each is designed for a procedure that
  takes the same number of arguments.
  - This is what enabled me to easily deal with builtin procedures and to
  keep my eval function from turning into a really long conditional
  statement.

Limitations and bugs
1. There is an issue with how I interpret what is a variable though it
  does not really come into play in the requirements of this project.
  - Because any symbol my interpreter sees it treats as a variable it
  is not possible to use symbols for any other reason unless they are
  never evaluated. So in a quote expression they may be returned as is
  but in other places they do not. I have in another version of the
  project a list() function and it does not work the same as built in
  list(). This is because my interpreter will evaluate all arguments
  of the list when building it and all symbols will need to be bound
  to something or they will fail. The racket list function does not
  do this and will return a list with a symbol in it if it is just
  a symbol. I could probably get this behaviour if I did not throw
  an error when a variable is found to be unbound, but for the
  project we were asked to make I found it better to throw the error
  to track down issues in my interpreter.
2. There are no other issues or bugs I could find. However this probably
  means that I didn't think of the right tests. I beleive all the expected
  functionality works as it should.

Additional documentation
- I think I want to put the report together by doing this and then
  addressing each of the requirments as they are needed. This way I can
  just walk through the important parts of the implementation and talk
  about data structures etc. in the appropriate sections.

Testing
- take the assignment funcitons as 2 of the tests.
- look through and find some that are a little more complex
- if you don't find 5 you like then write another one or two that
  show of the veratility

Other thoughts
- If you work through the whole thing like mentioned in additonal doc
  then put in some extra comments on the process
- You can express some of the things that your implementation does
  well and how it makes it more extendable as well
- flex a little on how easy it is to add things and to work with it

#####
organize by section
introduction - explain what you are going to do and how to read the document
  - a hybrid of program documentation and project report

MyEval - first to explain what it does
Lambda - is most important as it informed how you did a number of other things
Bindings - next because this is the most affected by lambda
Simple operator - This sort of goes with bindings
Let
letrec

testing

any additional comments